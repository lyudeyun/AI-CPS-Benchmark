%% Simulation and Inputs Generation
% Wherein we demonstrate how to generate various input signals.

%% Initialization
% The following script creates a default interface with the
% AbstractFuelControl model.
clear; close all;
BrDemo.InitAFC;
BrAFC

%% Providing Directly Input Signals
% We can provide non-constant inputs to the system by directly giving them 
% as argument to the Sim command.
time_u = 0:.1:30;
pedal_angle = 60 - 60*exp(-0.5*time_u);
engine_speed = 100*cos(time_u) + 1000;
U = [time_u' pedal_angle' engine_speed'];  % order matters!
   
BrAFC.Sim(0:.05:30,U); 
BrAFC.PlotSignals({'Pedal_Angle','Engine_Speed','cyl_air', 'cyl_fuel', 'AF'}); 

%% Fixed Step Input Generation (1)
%
% To interact with the system we can also use parameterized input generators. For
% instance, parameters can represent control points, and the input generated by 
% some interpolation between these points.

AFC_UniStep3 = BrAFC.copy();  % Creates a copy of the system interface 
input_gen.type = 'UniStep';   % uniform time steps 
input_gen.cp = 3;             % number of control points
AFC_UniStep3.SetInputGen(input_gen); 

%%
% This created a signal generator parameterized with 3 control points for
% each input. The corresponding parameters have been added to the
% interface:

AFC_UniStep3.PrintParams();

%% Fixed Steps Input Generation (2)
% We set values for the control points and plot the result. 
AFC_UniStep3.SetParam({'Engine_Speed_u0','Engine_Speed_u1','Engine_Speed_u2'}, [ 1000 900 1100]);
AFC_UniStep3.SetParam({'Pedal_Angle_u0','Pedal_Angle_u1','Pedal_Angle_u2'}, [ 20 60 30]);
AFC_UniStep3.Sim(0:.05:40);
figure; AFC_UniStep3.PlotSignals({'Pedal_Angle','Engine_Speed','cyl_air', 'cyl_fuel', 'AF'});

%% Variable Steps Input Generation
% We can have variable step inputs and also different numbers of control 
% points and interpolation methods.

AFC_VarStep = BrAFC.copy();                % Creates a copy of the system interface 
input_gen.type = 'VarStep';                % uniform time steps 
input_gen.cp = [2 3];                      % number of control points
input_gen.method = {'previous', 'linear'};  % interpolation methods - see help of interp1.
AFC_VarStep.SetInputGen(input_gen); 

%%
% This creates a new input parameterization:
AFC_VarStep.PrintParams();

%% Changing Input Functions
% We set values for the control points and plot the result. The 
% semantics is input_ui holds for input_dti seconds 
AFC_VarStep.SetParam({'Engine_Speed_u0','Engine_Speed_dt0','Engine_Speed_u1', 'Engine_Speed_dt1', 'Engine_Speed_u2'},...
                     [ 1000 10 900 30 1100]);
AFC_VarStep.SetParam({'Pedal_Angle_u0','Pedal_Angle_dt0','Pedal_Angle_u1'}, [20 15 60]);
AFC_VarStep.Sim(0:.05:40);
figure; AFC_VarStep.PlotSignals({'Pedal_Angle','Engine_Speed','cyl_air', 'cyl_fuel', 'AF'});

%% Mixing Signal Generators for Inputs (1)
% It is possible to mix different ways to generate signals for the
% different inputs. To do this, Breach provides a number of classes of
% signal generators. For example: 

pedal_angle_gen = pulse_signal_gen({'Pedal_Angle'}); % Generate a pulse signal for pedal angle
engine_gen      = fixed_cp_signal_gen({'Engine_Speed'}, ... % signal name
                                       3,...                % number of control points
                                      {'spline'});        % interpolation method 
        
%%
% Several signal generators can be glued together in a special Breach System: 

InputGen = BreachSignalGen({pedal_angle_gen, engine_gen});

%%
% InputGen is a Breach System in its own right. Meaning we can change
% parameters, plot signals, etc, independantly from a Simulink model
InputGen.SetParam({'Engine_Speed_u0','Engine_Speed_u1','Engine_Speed_u2'},...
                        [1000 1100 500]);
InputGen.SetParam({'Pedal_Angle_base_value', 'Pedal_Angle_pulse_period', ...
                         'Pedal_Angle_pulse_amp','Pedal_Angle_pulse_width','Pedal_Angle_pulse_delay'}, ... 
                         [0 15 30 .5 10]);
InputGen.PrintParams();

%% Mixing Signal Generators for Inputs (2)
% We can attach InputGen to the Simulink model and simulate as follows.

BrAFC.SetInputGen(InputGen);
BrAFC.Sim(0:.05:40);
figure; BrAFC.PlotSignals({'Pedal_Angle', 'Engine_Speed','cyl_fuel', 'AF'});

%% Writing a New Signal Generator (1)
% If the available signal generators are not enough, it is easy to write a
% new one. The idea is to write a simple new class implementing a computeSignals
% method.
type my_signal_generator;

%% Writing a New Signal Generator (2)
% We can use the new signal generator as the builtin ones  
my_input_gen = my_signal_generator(2)         % creates an instance with lambda=2
MyInputGen = BreachSignalGen({my_input_gen}); % Makes it a Breach system 

% Then plug it to the Simulink model:
BrAFC_MyGen = BrAFC.copy();
BrAFC_MyGen.SetInputGen(MyInputGen);          
BrAFC_MyGen.PrintParams();  % Makes sure the new parameters are visible


%% Writing a New Signal Generator (3)
% And simulate to see what happens.
BrAFC_MyGen.Sim(0:.05:40);
figure; BrAFC_MyGen.PlotSignals({'Pedal_Angle', 'Engine_Speed','cyl_fuel', 'AF'});

%% Setting Time for Simulation
% If only the end time is specified, Breach collects signals at time
% instants decided by the solver used by Simulink. We can also force
% Simulink to provide outputs at specific times, e.g., every fixed time
% steps. 

AFC_Time= BrAFC.copy(); % Creates a copy of the interface object 
AFC_Time.Sim(0:.01:40); % Run Simulink simulation from time 0 to time 40 
                        % and collect outputs at time steps of 0.01. 
                           
%% 
% Note that Simulink will still use a variable step solver in this case.
% This only affects the output times. To change solver options (e.g., 
% switch to  a fixed step solver), the proper way is to open the original
% model, update solver options, and re-create the Breach interface. 
 
%% 
% <latex>\bigskip</latex>

%% 
% Also we don't need to specify fixed time steps, e.g., the following will
% work too:
AFC_Time.Sim([0 1 5 10 20 21 30]); % Run Simulink simulation from time 0 to time 30 
                                   % and collect outputs at times 0, 1, 5, etc 

%%
% <latex>\bigskip</latex>

%%
% Finally, we can set a default time to run simulations:
AFC_Time.SetTime(0:.1:40);
AFC_Time.Sim(); 
